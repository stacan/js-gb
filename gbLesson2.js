/*  Основные операторы */


/*
let goodsCount = 10;

if (goodsCount > 0) {
    console.log('Количество товаров в корзине : ' + goodsCount);
} else {
    console.log('Корзина пуста.');
}
*/
//=================================
/*   тоже самое через тернарый оператор ?     */

/*
let goodsCount = 0;

goodsCount > 0 ?
  console.log('Количество товаров в корзине : ' + goodsCount):
  console.log('Корзина пуста');
*/
//===================================
/*  Через if else*/
/*
const good = 'Груши';

if (good === 'Бананы') {
    console.log('Стоимость бананов 50 руб');
} else {
  if (good === 'Манго') {
    console.log('Стоимость манго 80 руб');
  } else {
    if (good === 'Яблоки' || good === 'Груши') {
     console.log('Стоимость яблок и груш 40 руб');   
    } else {
        console.log('Неизвестный фрукт');
    }
  }
}
*/
//===================================
/*  Через  if   else   else if*/

/*
const good = 'Бананы';

if (good === 'Бананы') {
    console.log('Стоимость бананов 50 руб');
} else if (good === 'Манго') {
    console.log('Стоимость манго 80 руб');
} else if (good === 'Яблоки' || good === 'Груши') {
    console.log('Стоимость яблок и груш 40 руб');
} else {
    console.log('Неизвестный фрукт');
}
*/
//=====================================
/*      Через switch  */ 
/*

const good = 'Авокадо';

switch (good) {
    case 'Бананы':
        console.log('Стоимость бананов 50 руб');
        break;
    case 'Манго':
        console.log('Стоимость манго 80 руб');
        break; 
    case 'Яблоки':
    case 'Груши': 
    case 'Авокадо':   
        console.log('Стоимость яблок и груш и авокадо 40 руб');
        break;  
    default:
        console.log('Неизвестный фрукт');         
}
*/
//=====================================
// switch через функцию
/*
const good = 'Яблоки';

function checkGood(good) {
switch (good) {
    case 'Бананы':
        return 'Стоимость бананов 50 руб';
    case 'Манго':
        return 'Стоимость манго 80 руб'; 
    case 'Яблоки':
    case 'Груши': 
    case 'Авокадо':   
        return 'Стоимость яблок и груш и авокадо 40 руб';
        break;  
    default:
        return 'Неизвестный фрукт';         
}
}
//console.log(checkGood(good));
//console.log(checkGood('Авокадо'));
*/
//======================================
//34:40
/* декларативный и императивный подходы JS и чистые функции
*/

/*https://park.mail.ru/materials/video/867/  4:00 !!!!!!!!
*/
//====================================
/*
https://tproger.ru/translations/imperative-declarative-programming-concepts/

Это уже субъективно, но я считаю, что код ниже нечитаем. Я не могу с первого взгляда понять, что происходит — вместо этого мне приходится читать код построчно.
*/

// императивно и декларативно
/*
Напишите функцию, называющуюся double, которая принимает массив чисел и возвращает новый массив, каждый элемент которого в два раза больше входного: double([1,2,3]) -> [2,4,6].
*/
/*
//императивно
function double (arr) {
  let results = []
  for (let i = 0; i < arr.length; i++){
    results.push(arr[i] * 2)
  }
  return results
}
console.log(double([1, 2, 3]));

//декларативно
function double (arr) {
  return arr.map((item) => item * 2)
}
console.log(double([1, 2, 3]));
//======================================
/*
// императивно и декларативно
Напишите функцию, называющуюся add, которая принимает массив и возвращает сумму всех его элементов: add([1,2,3]) -> 6.

// императивно
function add (arr) {
  let result = 0
  for (let i = 0; i < arr.length; i++){
    result += arr[i]
  }
  return result
}
console.log(add([1, 2, 3]));

// или декларативно
function add (arr) {
    return arr.reduce((prev, current) => prev + current, 0)
  }

console.log(add([1, 2, 3]));
*/
//====================================
// императивно и декларативно
/*
Используя jQuery (или чистый JavaScript), добавьте обработчик события click к элементу с id, равным btn. По нажатию переключите класс highlight и смените текст на Add Highlight или Remove Highlight, в зависимости от текущего состояния элемента.*/

// императивно
/*
$("#btn").click(function() {
  $(this).toggleClass("highlight")
  $(this).text() === 'Add Highlight'
    ? $(this).text('Remove Highlight')
    : $(this).text('Add Highlight')
})
// декларативно, это на React'e. 
<Btn>
  onToggleHighlight={this.handleToggleHighlight}
  highlight={this.state.highlight}>
    {this.state.buttonText}
</Btn>
*/
//==========================================
// функция "скажи цену"
/*
function sayPrice(price = 'неизвестна') {
    console.log(`Цена товара: ${price} башкирских рублей`);//шаблонизация строки
    console.log('Цена товара: '+ price +' башкирских рублей'); //идентичная строка, только хуже код
}
sayPrice(120);
sayPrice();
*/
// функция "скажи цену"=====================
/*
function sayPrice(price = 'неизвестна ') {
    console.log(`Цена товара: ${price + 34} кубинских юаней`);
}
sayPrice(120);
sayPrice();
*/
//===========================================
/*
function sum(a, b) {
  return a + b;
}
console.log(sum(4, 9));
*/
/*
  ======== ЛОГИКА ПОСТРОЕНИЯ ПРИЛОЖЕНИЙ =========

зачем нужна такая функция как на строке 199 ? такая 
небольшая по обьему и простое вычисление, для чего
 нужно это дробление, на такие мелкие кусочки ?

Мы можем взять и нафигачить какую то большую функцию,
которая еще к тому же будет содержать какую то
вспомогательную логику, внутри хранить, но то то не 
будет хорошо.

Допустим у нас есть какая то генерация строки, строки
88, 90, 94, которые каждый раз повторяются. Мы можем
это вынести в отдельную функцию, которая будет 
продуцировать эту строку, и мы можем вынести это в 
отдельную функцию (182 - 187), которая будет
продуцировать эту строку и передавать их обратно в 
те же строки. Значения case (87, 89, 91, 92, 93) 
будут хранить какие то конкретные значения
40, 50, 80. И мы уже сможем ретёрнить результат вызова
функции (88, 90, 94), которая нам будет
продуцировать строку, например getStringPrice либо
getPriceString, что нибудь в этом духе и передавать
соответствующую стоимость, а наша функция (182)
будет генерировать что то в этом духе(sayPrice), и 
цена товара будет сгенерирована (183).

То есть так более правильный подход к разработке. 

Если вы видите что у вас уже мешается логика, например
внутри какой то логики у вас еще присутствует 
дополнительная логика, например происходят какие то
дополнительные вычисления, то лучше все таки выносить
это в отдельные функции, либо методы (если это ООП)
и уже ими пользоваться.

Переписываем функцию с sayPrice.
*/
/*
function checkGood(good) {
  switch (good) {
    case 'Бананы':
        return sayPrice(50);
    case 'Манго':
        return sayPrice(80); 
    case 'Яблоки':
    case 'Груши': 
    case 'Авокадо':   
        return sayPrice(40);
    default:
        return 'Неизвестный фрукт';         
  }
}

function sayPrice(price = 'неизвестна') {
  return `Цена товара: ${price} башкирских рублей`;
}
  console.log(checkGood('Яблоки'));
  console.log(checkGood('Авокадо'));
  console.log(checkGood('Манго'));
  console.log(checkGood('Бананы'));
  console.log(checkGood('Арбуз'));
*/
/*
Мы можем описать функцию как и внутри функции, но 
тогда мы будем общаться внутри функции, родительской,
но тогда она не будет доступна где то выше.
В данном случае мы написали вспомогательную функцию в 
глобальной области видимости (259), и можем 
ее спокойно вызвать (247, 249, 253) внутри 
другой функции.
*/
//===================================
//обращение к переменным
/*
//const good = 'Яблоки'; //обращение к переменной
//const good = 'Авокадо';//только по одной ((
const good = 'Манго';
//const good = 'Арбуз';

function checkGood() { //пустая функция
  switch (good) {      //работает замыкание
    case 'Бананы':
        return sayPrice(50); 
    case 'Манго':
        return sayPrice(80); 
    case 'Яблоки':
    case 'Груши': 
    case 'Авокадо':   
        return sayPrice(40);
    default:
        return 'Неизвестный фрукт';         
  }
}

function sayPrice(price = 'неизвестна') {
  return `Цена товара: ${price} башкирских рублей`;
}
  console.log(checkGood('')); //пустая функция
//через замыкание (286) можно обращаться и к функциям
//и к переменным
*/
//======================================
/*
Раз уж мы с вами заговорили про аргументы, то
можно как то организовывать более сложные функции,
делать более классные вещи.

Выше в функции мы что то передавали, вызывается какаято
вспомогательная функция, в ней что то генерируется, 
строчка, и возвращается нам.

Это все хорошо, но это актуально для одного товара, 
а если у нас сто товаров, и мы купили 13 килограмм
яблок, нужно спродуцировать ответ.

Я (Артем Шашков) накидал примерчик.
Данная функция максимально корректна,
максимально идеальна.
Так должен выглядеть один логический кусок.
*/
/*
function getGoodPrice() { 
  switch (good.toLowerCase()) {  //не привязан к регистру    
    case 'бананы':
        return 50; 
    case 'манго':
        return 80; 
    case 'яблоки':
    case 'яблочки':
    case 'груши': 
    case 'авокадо':   
        return 40;
    default:
        return false;         
  }
}
*/
/* реорганизуем логику,  функция ищет товар, 
и возвращает суммарную стоимость всех товаров
данного наименования.


1:15:00

1:21 возвращает стоимость исходя из количества
1:22 получаем стоимость товара 

что нужн сделать ? реализовываем алгоритмы в 
голове, логику
*/
//============  count*price  ============
/*
function getGoodPrice(good) { 
  switch (good.toLowerCase()) {  //не привязан к регистру    
    case 'бананы':
        return 50; 
    case 'манго':
        return 80; 
    case 'яблоки':
    case 'яблочки':
    case 'груши':  
    case 'авокадо':   
        return 40;
    default:
        return false;         
  }
}

function getPriceByCount(good, count = 1) {
  const price = getGoodPrice(good);

  if (!price) return false;

  return price*count;
}

console.log(getPriceByCount('ЯБЛоки', 12));
console.log(getPriceByCount('МанГо', 17));
console.log(getPriceByCount('АРБУЗ', 43));
console.log(getPriceByCount('Груши',));
*/
/*
let result = getPriceByCount('яблоки', 4);
if (result) console.log(result); // второй вывод ответа
*/
//=========  FUNCTION DECLARATION  ==========

//два сценария написания функции: 
//вызов функции либо до описания функции:
/*function myFunc(){
}
myFunc();
*/
//либо после
/*myFunc();
function myFunc(){
}
*/
//=========== FUNCTION EXPRESSION  ============
/*
const myFunc = {} => {}; //нет собственного this
//это не функция, это ссылка на функцию

const myFunc2 = function() {};
*/ 
//======  пример использования this  =======
/*
const myFunc = () => {
  console.log(this)
}

function myFunc2(arg1){
  var myArg = arg1;
  this.some = '123';
  console.log(this);
}
const obj = {
  name:'Vasya',
  getName() {
    console.log(this);
  },
  getName2: () => {
    console.log(this)
  }
}

obj.getName();
obj.getName2();
*/
//==============  РЕКУРСИЯ  ==============
/*
function recursion(x) {
    if (x <= 0 || !Number.isInteger(x))
    return 'Задайте целое число больше 0';
  
    if (x === 3) {
      return '3';
    }
  
    return recursion(x - 1) + '' + x;
  }
  console.log(recursion(62));
  //две задачки, как решить через рекурсию
  //регулярно задают на собеседованиях
  //console.log(sum(4)(6)()); //10
  //console.log(sum(4)(6)......(8)); //10
  */
  //1:58:00
  
  
  
  
  
  
  
  
  
  
  
  
  
  